# WebSocket Protocol Specification

**Version**: 0.2.0
**Status**: Production
**Last Updated**: 2026-02-16

Olympus Gateway uses WebSocket for real-time bidirectional communication between clients (web dashboard, TUI, Telegram bot integrations, registered CLI workers) and the server.

---

## Connection

### Endpoint

```
ws://localhost:8200/ws
```

- **Default port**: `8200` (configurable via `DEFAULT_GATEWAY_PORT`)
- **Default host**: `127.0.0.1` (configurable via `DEFAULT_GATEWAY_HOST`)
- **Path**: `/ws` (constant `GATEWAY_PATH`)

### Authentication

Immediately after connection, client MUST send a `connect` message with API key:

```typescript
{
  type: 'connect',
  id: 'unique-msg-id',
  timestamp: 1708056000000,
  payload: {
    clientType: 'web' | 'tui' | 'cli',
    protocolVersion: '0.2.0',
    apiKey?: string
  }
}
```

Server responds with `connected` message:

```typescript
{
  type: 'connected',
  id: 'msg-id',
  timestamp: 1708056000000,
  payload: {
    protocolVersion: '0.2.0',
    sessionId: 'sess-abc123'
  }
}
```

### Auto-Reconnect

Client library implements exponential backoff:
- Max 10 reconnection attempts
- Base delay: 1000ms
- Delay formula: `1000 * 2^(attempt_count)`

### Heartbeat

Client sends `ping` every 30 seconds. Server responds with `pong`:

```typescript
// Client → Server
{ type: 'ping', id: 'msg-id', timestamp: ..., payload: {} }

// Server → Client
{ type: 'pong', id: 'msg-id', timestamp: ..., payload: {} }
```

---

## Message Format

All WebSocket messages follow a common envelope structure:

```typescript
interface WsMessage<T = unknown> {
  type: string;        // Event type identifier
  id: string;          // Unique message ID (for correlation, RPC requests)
  timestamp: number;   // UNIX milliseconds
  payload: T;          // Event-specific data
}
```

### Message ID

- Generated by client (`randomUUID()` or equivalent)
- Used for RPC request-response correlation
- For events, allows server to acknowledge or detect duplicates

---

## Client → Server Events

Client sends messages with these event types:

### `connect`
Authenticate with the gateway.

**Payload**:
```typescript
interface ConnectPayload {
  clientType: 'tui' | 'web' | 'cli';
  protocolVersion: string;
  apiKey?: string;
}
```

**Response**: `connected` event

### `subscribe`
Subscribe to events for a specific run or session.

**Payload**:
```typescript
interface SubscribePayload {
  runId?: string;      // Subscribe to a specific run
  sessionId?: string;  // Subscribe to a specific session
}
```

**Effect**: Server will send run-scoped or session-scoped events to this client

### `unsubscribe`
Unsubscribe from events for a run or session.

**Payload**:
```typescript
interface UnsubscribePayload {
  runId?: string;      // Unsubscribe from a specific run
  sessionId?: string;  // Unsubscribe from a specific session
}
```

### `cancel`
Cancel a running operation.

**Payload**:
```typescript
interface CancelPayload {
  runId?: string;   // Cancel a specific run (or all if omitted)
  taskId?: string;  // Cancel a specific task within a run
}
```

### `ping`
Heartbeat (no action required by server, responds with `pong`).

**Payload**:
```typescript
interface PingPayload {}
```

### `rpc`
Execute a remote procedure call.

**Payload**:
```typescript
interface RpcRequestPayload {
  method: string;
  params?: Record<string, unknown>;
}
```

**Response**: `rpc:ack` (immediate), then `rpc:result` or `rpc:error`

---

## Server → Client Events

Server broadcasts or unicasts events with these types.

### Broadcast Events (all connected clients)

#### `connected`
Authentication success response.

**Payload**:
```typescript
interface ConnectedPayload {
  protocolVersion: string;
  sessionId: string;
}
```

#### `runs:list`
Full run list (initial snapshot + on change).

**Payload**:
```typescript
interface RunsListPayload {
  runs: RunStatus[];
}

interface RunStatus {
  runId: string;
  status: 'running' | 'completed' | 'cancelled' | 'failed';
  prompt: string;
  createdAt: number;
  phase: number;       // -1 to 8
  phaseName: string;
  tasks: TaskPayload[];
}
```

#### `sessions:list`
Active session list (initial snapshot + on change).

**Payload**:
```typescript
interface SessionsListPayload {
  sessions: SessionInfo[];
  availableSessions?: AvailableSession[];
}

interface SessionInfo {
  id: string;
  name: string;
  chatId: number;
  status: 'active' | 'closed';
  projectPath: string;
  createdAt: number;
  lastActivityAt: number;
}
```

#### `cli:stream`
Real-time CLI stdout chunk during execution.

**Payload**:
```typescript
interface CliStreamChunk {
  sessionKey: string;   // Unique key identifying the CLI session
  chunk: string;        // Partial stdout content
  timestamp: number;    // When chunk was generated
}
```

**Note**: Chunks arrive in order, may be partial lines. Client should buffer until newline or timeout.

#### `cli:complete`
CLI execution completed (success or error).

**Payload**:
```typescript
interface CliRunResult {
  success: boolean;
  text: string;
  sessionId: string;
  model: string;
  usage: {
    inputTokens: number;
    outputTokens: number;
    cacheCreationTokens: number;
    cacheReadTokens: number;
  };
  cost: number;
  durationMs: number;
  numTurns: number;
  error?: {
    type: 'timeout' | 'parse_error' | 'session_not_found' | 'permission_denied' | 'api_error' | 'spawn_error' | 'killed' | 'unknown';
    message: string;
    exitCode?: number;
  };
}
```

#### `gemini:status`
Gemini Advisor status (initial snapshot + on change).

**Payload**:
```typescript
interface GeminiAdvisorStatus {
  isRunning: boolean;
  lastAnalyzed?: number;
  cacheCount: number;
  projectCount: number;
  error?: string;
}
```

#### `gemini:analysis`
Gemini project analysis completed.

**Payload**:
```typescript
interface GeminiProjectAnalysis {
  encodedPath: string;
  description: string;
  dependencies: string[];
  keyFiles: Array<{
    path: string;
    description: string;
  }>;
  workHistory?: string;
}
```

---

### Worker Events (broadcast)

#### `worker:task:assigned`
Task assigned to a registered worker.

**Payload**:
```typescript
interface WorkerTaskAssigned {
  workerId: string;
  taskId: string;
  prompt: string;
}
```

#### `worker:task:completed`
Worker completed a task.

**Payload**:
```typescript
interface WorkerTaskCompleted {
  workerId: string;
  taskId: string;
  result: CliRunResult;
}
```

#### `worker:task:timeout`
Worker task timed out (30 minutes default).

**Payload**:
```typescript
interface WorkerTaskTimeout {
  workerId: string;
  taskId: string;
  partialResult?: CliRunResult;
}
```

#### `worker:task:final_after_timeout`
Worker completed after timeout delay.

**Payload**:
```typescript
interface WorkerTaskFinalAfterTimeout {
  workerId: string;
  taskId: string;
  result: CliRunResult;
}
```

---

### Agent Events (legacy/hybrid mode only)

#### `agent:progress`
Agent task progress update.

**Payload**:
```typescript
interface AgentProgress {
  phase: number;
  message: string;
}
```

#### `agent:result`
Agent task completed.

**Payload**:
```typescript
interface AgentResult {
  taskId: string;
  result: unknown;
}
```

#### `agent:error`
Agent encountered an error.

**Payload**:
```typescript
interface AgentError {
  taskId: string;
  error: string;
}
```

#### `agent:approval`
Agent requires approval for an action.

**Payload**:
```typescript
interface AgentApprovalRequest {
  taskId: string;
  action: string;
  details: Record<string, unknown>;
}
```

---

### Context Events (Context OS)

#### `context:created`
New context created.

#### `context:updated`
Context updated.

#### `context:merge_requested`
Merge operation initiated.

#### `context:merged`
Merge completed.

#### `context:conflict_detected`
Merge conflict detected.

#### `context:reported_upstream`
Report to parent context completed.

---

### Session Events (subscribed clients only)

These events are only sent to clients subscribed to a specific `sessionId`.

#### `session:screen`
Terminal screen snapshot (full session output).

**Payload**:
```typescript
interface SessionScreenPayload {
  sessionId: string;
  output: string;        // Full terminal content (replace, not append)
}
```

#### `session:error`
Session error occurred.

**Payload**:
```typescript
interface SessionErrorPayload {
  sessionId: string;
  error: string;
}
```

#### `session:closed`
Session terminated.

**Payload**:
```typescript
interface SessionClosedPayload {
  sessionId: string;
}
```

---

## RPC Protocol

WebSocket RPC follows a request-acknowledge-result pattern for stateful remote calls.

### Request → Acknowledge → Result/Error Flow

```
Client sends:  { type: 'rpc', id: 'req-123', payload: { method: 'health', params: {} } }
Server sends:  { type: 'rpc:ack', id: 'req-123', payload: { ... } }
Server sends:  { type: 'rpc:result', id: 'req-123', payload: { result: {...} } }
               OR
Server sends:  { type: 'rpc:error', id: 'req-123', payload: { code: 'TIMEOUT', message: '...' } }
```

### RPC Request

**Payload**:
```typescript
interface RpcRequestPayload {
  method: string;
  params?: Record<string, unknown>;
}
```

### RPC Response Types

#### `rpc:ack`
Immediate acknowledgment (optional, indicates server received request).

**Payload**:
```typescript
interface RpcAckPayload {
  requestId: string;
  message?: string;
}
```

#### `rpc:result`
Successful result.

**Payload**:
```typescript
interface RpcResultPayload {
  requestId: string;
  result: unknown;
}
```

#### `rpc:error`
Error response.

**Payload**:
```typescript
interface RpcErrorPayload {
  requestId: string;
  code: 'PARSE_ERROR' | 'METHOD_NOT_FOUND' | 'INVALID_PARAMS' | 'INTERNAL_ERROR' | 'UNAUTHORIZED' | 'TIMEOUT' | 'AGENT_BUSY' | 'WORKER_LIMIT_REACHED';
  message: string;
  details?: unknown;
}
```

---

### Available RPC Methods

#### System Methods

##### `health`
**Params**: (none)
**Returns**:
```typescript
{
  status: 'ok',
  uptime: number,
  version: string
}
```

##### `status`
**Params**: (none)
**Returns**:
```typescript
{
  agentState: string,
  activeWorkers: number,
  connectedClients: number,
  activeSessions: number
}
```

#### Agent Methods

##### `agent.command`
**Params**:
```typescript
{
  command: string,
  projectPath?: string,
  autoApprove?: boolean
}
```
**Returns**:
```typescript
{
  taskId: string,
  status: 'accepted' | 'rejected',
  message: string
}
```

##### `agent.status`
**Params**: (none)
**Returns**:
```typescript
{
  state: string,
  currentTask: { id, command, state, startedAt, progress? } | null,
  activeWorkers: number,
  queuedCommands: number
}
```

##### `agent.cancel`
**Params**:
```typescript
{
  taskId?: string
}
```
**Returns**:
```typescript
{
  cancelled: boolean,
  message: string
}
```

##### `agent.history`
**Params**:
```typescript
{
  limit?: number,
  offset?: number
}
```
**Returns**:
```typescript
{
  tasks: Array<{
    id: string,
    command: string,
    status: 'success' | 'partial' | 'failed',
    summary: string,
    duration: number,
    timestamp: number,
    workerCount: number
  }>,
  total: number
}
```

##### `agent.approve`
**Params**:
```typescript
{
  taskId: string
}
```
**Returns**:
```typescript
{
  approved: boolean,
  message: string
}
```

#### Worker Methods

##### `workers.list`
**Params**: (none)
**Returns**:
```typescript
{
  workers: Array<{
    id: string,
    status: 'pending' | 'running' | 'completed' | 'failed' | 'timeout',
    projectPath: string,
    startedAt: number,
    duration?: number,
    exitCode?: number | null,
    outputPreview?: string
  }>
}
```

##### `workers.terminate`
**Params**:
```typescript
{
  workerId: string
}
```
**Returns**:
```typescript
{
  terminated: boolean,
  message: string
}
```

##### `workers.output`
**Params**:
```typescript
{
  workerId: string,
  offset?: number,
  limit?: number
}
```
**Returns**:
```typescript
{
  workerId: string,
  output: string,
  totalLength: number
}
```

#### Session Methods

##### `sessions.list`
**Params**: (none)
**Returns**:
```typescript
{
  sessions: SessionInfo[],
  availableSessions?: AvailableSession[]
}
```

##### `sessions.discover`
**Params**: (none)
**Returns**:
```typescript
{
  sessions: SessionInfo[]
}
```

---

## Connection Lifecycle

### Normal Flow

```
1. Client initiates WebSocket connection to /ws endpoint
   ↓
2. Client sends 'connect' message with API key + clientType
   ↓
3. Server validates API key, creates session
   ↓
4. Server sends 'connected' message (includes sessionId)
   ↓
5. Server broadcasts initial snapshots:
   - runs:list (active runs)
   - sessions:list (active sessions)
   - gemini:status (Gemini Advisor state)
   ↓
6. Client can now:
   - Subscribe to runs/sessions
   - Send RPC calls
   - Receive events
   ↓
7. Client sends 'ping' every 30 seconds (heartbeat)
   - Server responds with 'pong'
   ↓
8. Client sends 'disconnect' or WebSocket closes
   - Server cleans up client state
```

### Reconnection Flow

```
1. Client detects connection loss (onclose)
   ↓
2. Calculate exponential backoff delay
   ↓
3. Wait, then attempt reconnect
   ↓
4. If successful: repeat steps 2-6 of normal flow
   - Re-subscribe to previous runs/sessions
   ↓
5. After 10 failed attempts: stop reconnecting
```

### Subscribe/Unsubscribe Flow

```
Client sends 'subscribe' with runId/sessionId
   ↓
Server marks client as interested in that run/session
   ↓
Server sends future events for that run/session to client
   ↓
Client can send 'unsubscribe' to stop receiving
```

---

## Error Handling

### Connection Errors

- **Auth failure**: Server closes connection immediately if API key is invalid
- **Protocol error**: Server may close if message is malformed (invalid JSON, missing fields)
- **Server error**: Server sends `error` event with code and message

### RPC Errors

RPC calls return `rpc:error` with one of:

| Code | Meaning |
|------|---------|
| `PARSE_ERROR` | Request payload is invalid JSON or missing required fields |
| `METHOD_NOT_FOUND` | RPC method does not exist |
| `INVALID_PARAMS` | Parameters do not match method signature |
| `INTERNAL_ERROR` | Server encountered an error executing the method |
| `UNAUTHORIZED` | Client is not authorized for this method |
| `TIMEOUT` | Method execution exceeded time limit |
| `AGENT_BUSY` | Agent is busy (legacy mode only) |
| `WORKER_LIMIT_REACHED` | Max concurrent workers limit reached |

### Timeout Behavior

- **RPC timeout**: Default varies by method, typically 30 seconds
- **Worker task timeout**: 30 minutes (partial result may be available)
- **Ping timeout**: If client doesn't receive `pong` within 60 seconds, client disconnects and attempts reconnect

---

## Constants

```typescript
const DEFAULT_GATEWAY_PORT = 8200;
const DEFAULT_GATEWAY_HOST = '127.0.0.1';
const GATEWAY_PATH = '/ws';
const HEARTBEAT_INTERVAL_MS = 30000;        // 30 seconds
const MAX_RECONNECT_ATTEMPTS = 10;
const RECONNECT_BASE_DELAY_MS = 1000;       // Exponential backoff: 1s * 2^n
const PROTOCOL_VERSION = '0.2.0';
```

---

## Implementation Notes

### Client Library (`@olympus-dev/client`)

The `OlympusClient` class provides a TypeScript implementation:

```typescript
import { OlympusClient } from '@olympus-dev/client';

const client = new OlympusClient({
  port: 8200,
  host: '127.0.0.1',
  clientType: 'web',
  apiKey: 'your-key'
});

client.connect();

// Subscribe to events
client.on('runs:list', (msg) => {
  console.log('Active runs:', msg.payload.runs);
});

// RPC call
client.send(createMessage('rpc', {
  method: 'health',
  params: {}
}));

// Auto-reconnect on disconnect (configurable)
client.disconnect();
```

### Server Implementation

Gateway uses `ws` library with WebSocketServer:
- One-to-many broadcasting for events
- Per-client subscription tracking
- RPC request-response correlation via message `id`
- Session timeout: 0 (infinite, no timeout)

### Gateway Modes

- **legacy**: Full Agent + Worker support (legacy v0.x behavior)
- **hybrid**: Both Agent and CLI Runner
- **codex**: CLI Runner only (slim mode, no Agent/Worker)

All modes support WebSocket protocol equally.

---

## Changelog

### v0.2.0 (2026-02-16)
- Unified message format with `id`, `timestamp`
- RPC protocol with request-acknowledge-result pattern
- Worker task events (`worker:task:*`)
- CLI streaming events (`cli:stream`, `cli:complete`)
- Gemini Advisor status/analysis events
- Context OS events (merge, conflict, report-upstream)
- Session screen/error/closed events

### v0.1.0
- Initial WebSocket protocol
- Basic connect, subscribe, event broadcast
- Agent events (legacy)
- Session list/screen events
